# Weather Data Storage System - Complete Project Blueprint

## 1. Project Overview

**Assignment:** 01 - Foundation of Data Structures
**Goal:** Develop a C++ system to systematically collect, store, and manage weather data (temperature) using 2D arrays and Abstract Data Types (ADTs).
**Core Challenge:** Efficiently mapping logical data (City names, Dates) to physical memory (2D Array indices) while handling cases where data is missing (Sparse Data) and scaling to 50+ cities over 75 years.

---

## 2. System Requirements Specification (SRS)

### 2.1 Functional Requirements

These are the specific features your code must implement:

1.  **Data Loading (Batch Processing):**
    - The system must read from an external file (`data.csv`) generated by the Python script.
    - It must parse `Year`, `City`, and `Temperature` from CSV lines.
    - It must map `Year` (e.g., 1950) to a zero-based index and `City` (e.g., "Pune") to a column index.
2.  **Data Storage:**
    - Data must be stored in a **2D Array** (`double**`) where:
      - **Rows** represent Years (Offset from a base year, e.g., 1950 -> Index 0).
      - **Columns** represent Cities.
3.  **Data Removal (Deletion):**
    - The system must allow removing a record for a specific `Year` and `City`.
    - "Removal" means resetting the cell to a "Sentinel Value" (`-999.0`) to mark it as empty.
4.  **Traversal & Reporting:**
    - **Row-Major Traversal:** Iterate through years (Memory Efficient, Cache Friendly).
    - **Column-Major Traversal:** Iterate through cities (Cache Inefficient).
    - **Sparsity Report:** Calculate the percentage of empty cells vs. filled cells.

### 2.2 Non-Functional Requirements

1.  **Performance:** Direct access to any record must be $O(1)$ (Time Complexity) after index mapping.
2.  **Scalability:** The system must handle the expanded dataset (1950-2025, 50 Cities).
3.  **Memory Management:** Use dynamic memory allocation (`new`/`delete`) for the 2D array.

---

## 3. Data Specifications (The Real-World Dataset)

The system is built to handle the `data.csv` generated by the generate_data Python script.

- **Time Range:** 1950 - 2025 (76 Years)
- **Base Year:** 1950 (Used for Index Offset Calculation)
- **Cities:** 50 Major Indian Cities (Delhi, Mumbai, Srinagar, etc.)
- **Temperature Logic:** Realistic ranges based on climate (e.g., Srinagar: -5°C to 30°C, Chennai: 20°C to 38°C).
- **Sparsity:** ~20% of the data is intentionally missing to test the "Sentinel Value" logic.

---

## 4. Implementation Guide

### 4.1 File Structure

Create these exact files in your project folder:

```
/WeatherProject
├── main.cpp               // The menu and user interaction
├── WeatherSystem.h        // Class definitions and constants
├── WeatherSystem.cpp      // The logic (insert, delete, traverse)
├── data.csv               // The generated dataset already present
└── generate_data.py       // The Python script already present
```

### 4.2 Class Design (`WeatherSystem.h`)

This header defines the ADT and the System structure.

### 4.3 Critical Logic (`WeatherSystem.cpp`)

These are the key algorithms you must implement.

**1. The Constructor (Memory Allocation)**

**2. Index Mapping (The "Base Year" Logic)**

**3. CSV Parsing**

1. Weather Record ADT Design
   Attributes:
   a. Date: String or custom structure (e.g., day/month/year).
   b. City: String, name of the city.
   c. Temperature: Double, temperature value for the city on the given date.
   Methods:
   a. insert(data): Insert a new weather record into the system.
   b. delete(data): Remove a weather record based on specified criteria (e.g., city and
   date).
   c. retrieve(city, year): Retrieve temperature data for a specific city and year.
2. Data Storage Class
   Attributes:
   a. 2D array to store temperature values, with rows representing years and columns
   representing cities.
   Methods:
   a. populateArray(): Populate the 2D array with temperature values.
   b. rowMajorAccess(): Implement row-major representation for accessing data.
   c. columnMajorAccess(): Implement column-major representation for accessing
   data.
   d. handleSparseData(): Manage scenarios with missing data (e.g., using sentinel
   values or sparse matrix representation).
   e. analyzeComplexity(): Provide time and space complexity analysis for storage
   and retrieval operations.

### 4.4 Main Execution (`main.cpp`)

1.  Define the `cities` vector (hardcode the list of 50 from the Python script so indices match).
2.  Initialize `WeatherSystem sys(76, cities);`
3.  Call `sys.loadFromCSV("data.csv");`
4.  Run the Menu Loop.

---

## 5. Complexity Analysis (For Report)

| Operation         | Time Complexity | Explanation                                                          |
| :---------------- | :-------------- | :------------------------------------------------------------------- |
| **Retrieve**      | $O(C)$          | Linear search to find City Index ($C$=50), then $O(1)$ array access. |
| **Insert**        | $O(C)$          | Same as retrieve; finding the column index takes linear time.        |
| **Delete**        | $O(C)$          | Finds index, then overwrites with `NO_DATA`.                         |
| **Row Traversal** | $O(R \times C)$ | Visits every cell once. Fast due to Spatial Locality.                |
| **Col Traversal** | $O(R \times C)$ | Visits every cell once. Slow due to Cache Misses.                    |

- **Space Complexity:** $O(R \times C)$. We allocate space for every possible Year/City combination (Dense Storage).
- **Optimization Note:** If we used a Hash Map (`std::unordered_map`) for city names, Time Complexity for Retrieve/Insert would drop to $O(1)$ average.

---

## 6. Build Instructions

Compile and run the c++ code. create a run.bat script
